package Array

// 287. 寻找重复数   --Medium
// 给定一个包含n+1个整数的数组nums，其数字都在[1, n]范围内（包括1和n），可知至少存在一个重复的整数。
// 假设nums只有一个重复的整数，返回这个重复的数。
// 你设计的解决方案必须不修改数组nums且只用常量级O(1)的额外空间。
// ==================================================
// 双指针==二进制==二分法
// 分析这个数组，索引从 0～n0～n0～n ，值域是 1～n1～n1～n 。值域，在索引的范围内，值可以当索引使。
// 比如，nums 数组：[4,3,1,2,2][4, 3, 1, 2, 2][4,3,1,2,2]
// 以 nums[0] 的值 4 作为索引，去到 nums[4]
// 以 nums[4] 的值 2 作为索引，去到 nums[2]
// 以 nums[2] 的值 1 作为索引，去到 nums[1]……
// 从一项指向另一项，将nums数组抽象为链表：4->2->1->3->2，如下图，链表有环。
// =================有环链表求入环口================================
// 两个快慢指针，从头节点出发，如果链表有环，快指针肯定可以在环内和慢指针相遇。没有环就不可能再相遇，相遇必在环内。
// D：从头节点到入环点的距离
// S1：从入环点到首次相遇点的距离
// S2：从首次相遇点到入环点的距离
//===========================
//相遇时，慢指针走的距离：D+S1D+S1D+S1
//假设相遇时快指针已经绕环 n 次，它走的距离：D+n(S1+S2)+S1D+n(S1+S2)+S1D+n(S1+S2)+S1
//因为快指针的速度是 2 倍，所以相同时间走的距离也是 2 倍：
//D+n(S1+S2)+S1=2(D+S1)D+n(S1+S2)+S1 = 2(D+S1)D+n(S1+S2)+S1=2(D+S1)
//即 (n−1)S1+nS2=D(n-1)S1+ nS2=D(n−1)S1+nS2=D
//我们不关心绕了几次环，取 n = 1 这种特定情况，消掉 S1：
//D=S2D=S2D=S2
//利用 D=S2 求入环点
//在循环的过程中，快慢指针相遇，位置相同了，可以确定出相遇点
//为了确定「入环点」，我们「人为制造」快慢指针在入环点相遇
//让快指针从头节点出发，速度改为和慢指针一样，慢指针留在首次相遇点，同时出发
//因为 D=S2D = S2D=S2 ，二者速度相同，所以会同时到达入环点
//===================================================
//https://leetcode.cn/problems/find-the-duplicate-number/solutions/262703/zhe-ge-shu-zu-you-dian-te-shu-suo-yi-ke-yi-yong-ku/

func FindDuplicate(nums []int) int {
	slow, fast := 0, 0
	for slow, fast = nums[slow], nums[nums[fast]]; slow != fast; slow, fast = nums[slow], nums[nums[fast]] {
	}
	fast = 0
	for slow != fast {
		slow, fast = nums[slow], nums[fast]
	}
	return fast
}
