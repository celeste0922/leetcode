package Array

// 41.缺失的第一个正数
// 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
// 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
// ======================================================
// 遍历一次数组把大于等于1的和小于数组大小的值放到原数组对应位置，
// 然后再遍历一次数组查当前下标是否和值对应，如果不对应那这个下标就是答案，否则遍历完都没出现那么答案就是数组长度加1。//天才
// ==========================官方思路===================================
// 方法一：哈希表
//我们对数组进行遍历，对于遍历到的数x，如果它在 [1,N]的范围内，那么就将数组中的第x−1个位置（注意：数组下标从0开始）
//打上「标记」。在遍历结束之后，如果所有的位置都被打上了标记，那么答案是 N+1，否则答案是最小的没有打上标记的位置加 1。
//打标记咯
//我们将数组中所有小于等于0的数修改为N+1；
//我们遍历数组中的每一个数x，它可能已经被打了标记，因此原本对应的数为∣x∣，其中∣∣为绝对值符号。
//如果 ∣x∣∈[1,N]，那么我们给数组中的第∣x∣−1个位置的数添加一个负号。
//注意如果它已经有负号，不需要重复添加；
//在遍历完成之后，如果数组中的每一个数都是负数，那么答案是 N+1，否则答案是第一个正数的位置加1。
//方法二：置换
//除了打标记以外，我们还可以使用置换的方法，将给定的数组「恢复」成下面的形式：
//如果数组中包含 x∈[1,N]，那么恢复后，数组的第x−1个元素为x。
//在恢复后，数组应当有[1, 2, ..., N]的形式，但其中有若干个位置上的数是错误的，每一个错误的位置就代表了一个缺失的正数。
//以[3, 4, -1, 1]为例，恢复后的数组应当为[1, -1, 3, 4]，我们就可以知道缺失的数为2。
//那么我们如何将数组进行恢复呢？我们可以对数组进行一次遍历，对于遍历到的数 x=nums[i]，如果 x∈[1,N]，我们就知道x应当出现在数组中的x−1的位置，
//因此交换nums[i]和 nums[x−1]，这样x就出现在了正确的位置。在完成交换后，新的nums[i]可能还在[1,N]的范围内，我们需要继续进行交换操作，直到 x∉[1,N]。
//注意到上面的方法可能会陷入死循环。如果 nums[i]恰好与 nums[x−1]相等，那么就会无限交换下去。此时我们有nums[i]=x=nums[x−1]，说明x已经出现在了正确的位置。
//因此我们可以跳出循环，开始遍历下一个数。
//由于每次的交换操作都会使得某一个数交换到正确的位置，因此交换的次数最多为N，整个方法的时间复杂度为O(N)。

func FirstMissingPositive(nums []int) int {
	n := len(nums)
	for index := 0; index < n; {
		if !(nums[index] < n && nums[index] > 0) {
			index++
			continue
		}
		if nums[index] == index+1 || nums[index] == nums[nums[index]-1] {
			index++
			continue
		}
		temp := nums[nums[index]-1]
		nums[nums[index]-1] = nums[index]
		nums[index] = temp
	}
	for i := 0; i < n; i++ {
		if nums[i] != i+1 {
			return i + 1
		}
	}
	return n + 1
}
