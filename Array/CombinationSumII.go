package Array

import "sort"

//40.组合总和 II
//给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
//candidates 中的每个数字在每个组合中只能使用 一次 。
//注意：解集不能包含重复的组合。
//=====================================================================================
//回溯的要素
//我们关心当下有什么选择，作了一个选择之后，会怎么限制下一个选择。 解空间树的节点是动态的，当前的选择决定了下一个选择是怎么展开的。
//所以，不仅要关注选择（选项），还要关注约束条件。 前者展开出一棵解的空间树，后者用来剪枝，剪去不能产生正确解的分支，避免无效搜索。
//第三个要素：目标（结束条件），明确了目标，就知道何时去将解加入解集。
//并且让你知道：搜索到某一步时，发现当前的部分解不能通向正确的完整解，搜下去没有意义。
//此时回退一步，撤销当前的选择，回到上一个选择的状态，做别的选择。
//此路不通，退回去，尝试别的路，回溯就是 choose, explore, unchoose 的过程。
//套路做法（可硬记）
//1.用 for 循环去枚举出所有的选择
//2.做出一个选择
//3.基于这个选择，继续往下选择（递归）
//上面的递归结束了，撤销这个选择，进入 for 循环的下一次迭代
//回溯 与 嵌套循环
//回溯是一种算法，递归不是算法，是一种计算机解决问题的方式。
//回溯是借助递归实现的。如果回溯不借助递归，它只能借助循环。
//用 for 循环枚举出当前的选项，选了一个，选下一个要嵌套一层循环，枚举出可选的选项。
//如果要选很多个，就导致多重的循环嵌套，很费力，代码也很丑。
//借助递归解决，递归和子递归就是层级嵌套的关系。
//树具有高度的结构重复性，每个节点，都是当前子树的根节点，调用递归负责当前子树的搜索。
//虚拟的解空间树
//回溯算法并没有显式地创建数据结构，也不是基于已有的数据结构做搜索。
//它是隐式地，通过递归，构建出一棵解的空间树。这个空间树中包含了所有的解。
//然后通过 dfs 的搜索方式，把解给全部找出来。
//如果说它难，应该难在确定出容易搜索（经过充分的剪枝）的解空间结构，剩下的 dfs 和回溯就比较简单了。
//====================================================================================
//组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。
//那么问题来了，我们是要同一树层上使用过，还是同一树枝上使用过呢？
//回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。
//所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。
//例子：candidates = [1, 1, 2], target = 3，（方便起见candidates已经排序了）
//此时在同一层遍历时就应该剪掉“1”这一枝
//==================================
//回溯三部曲
//1.递归函数参数
//2.递归终止条件
//3.单层搜索的逻辑

func CombinationSum2(candidates []int, target int) [][]int {
	sort.Ints(candidates)
	res_, path_ = make([][]int, 0), make([]int, 0, len(candidates))
	dfs_(candidates, target, 0)
	return res_
}

var (
	res_  [][]int //结果集
	path_ []int   //路径记录
)

func dfs_(candidates []int, target int, index int) {
	if target == 0 { //当传入的target=0说明前面路径上的值之和已经符合要求
		//新建一个切片并存入res，避免因底层内存共享而产生值的变化
		temp_ := make([]int, len(path_))
		copy(temp_, path_)
		res_ = append(res_, temp_)
		return
	}
	for i := index; i < len(candidates); i++ { //index，按顺序访问节点，当前层访问过的节点不再访问避免重复
		if candidates[i] > target { //第一个节点大于0则剩余节点都不符合要求-直接结束循环（已排序）
			break
		}
		if i > index && candidates[i] == candidates[i-1] { //在同一层搜索时，判断当前节点是否与上一节点相同，避免产生重复组合
			continue
		}
		path_ = append(path_, candidates[i])        //添加当前层节点路径（足迹）以便进入下一层节点
		dfs_(candidates, target-candidates[i], i+1) //进入下一层节点
		path_ = path_[:len(path_)-1]                //下一层节点已回溯，删除路径
	}
}

//=========================高手写的===========================
//func dfs_(nums []int, target int) [][]int {
//	ret := [][]int{}
//	for i, n := range nums {
//		if i > 0 && nums[i-1] == n {
//			continue
//		} else if target < n {
//			break
//		} else if target == n {
//			ret = append(ret, []int{n})
//			continue
//		}
//		for _, v := range dfs_(nums[i+1:], target-n) {
//			ret = append(ret, append([]int{n}, v...))
//		}
//	}
//	return ret
//}
